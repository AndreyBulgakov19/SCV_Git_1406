# Работа с Git

Предлагается краткое видео на английском языке - *что такое Git*

https://git-scm.com/video/what-is-git


## 1. Проверка наличия установленного Git

В терминале выполнить команду ***git version***
Если Git установлен, появится сообщение с информацией о версии программыю Иначе будет сообщение об ошибке.
## 2. Установка Git
Загружаем последнюю версию Git с сайта https://git-scm.com/downloads 
Устанавливаем с настройками по умолчанию 

## 3. Настройка Git
При первом исполтьзовании Git необходимо представиться. Для этого нужно ввести в терминале 2 команды:
```
git config -- global user.name 
git config --global user.email 
```
## 4. Создание репозитория
Получить репозиторий можно двумя способами
1) Клонировать уже имеющийся на каком-либо сервере репозиторий,при помощи команды 
```
git clone <адрес репозитория>
```

2) Импортировать в git свой собственный каталог проекта при помощи команды 

```
git init
```
В исходной папке появится скрытая папка *.git*

## 5. Запись изменений в репозиторий
Для того, чтобы вносить и фиксировать изменения в репозитории, используются следующие команды: 
```
- ***git status***
- ***git add***
- ***git commit***
- ***git diff***
```


  - ***Команда git status*** показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.


  *У файлов есть **4 состояния**:*


- __Неотслеживаемый (untracked)__ — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
- __Изменён (modified)__ — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
- __Подготовлен (staged)__ — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
- __Без изменений__ — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.

   - ***Команда git add <имя файла>*** добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита (фиксации изменений). 
   - ***Команда git commit*** берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок. 

   Также эта команда принимает несколько аргументов:

_-m_ - позволяет написать сообщение вместе с командой, не открывая редактор. Например git commit -m "Пофиксил баг";

_-a_ - переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом);

_--amend_ - заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.

### Советы для эффективного использования ***git commit***:

1) Коммитьте как можно чаще.
2) Одно изменение — один коммит: не помещайте все не связанные между собой изменения в один коммит, разделите их, чтобы было проще откатиться.

   - ***Команда git diff*** используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).
   
 ## 6. Просмотр истории коммитов. 
 Для просмотра истории всех сделанных коммитов используется команда ***git log***
   - ***Команда git log*** используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.
   - ***Команда git log --graph*** позволяет просмотреть историю ветвлений и слияний в виде дерева/графа. 

 ## 7. Перемещение между сохранениями.
Для переключения между ветками или перемещениями между сохранениями используется команда ***git checkout***
  
  Git позволяет вернуть выбранный файл к состоянию на момент определенного коммита. 
Для этого берется файл с определенным расширением, например, файл hello.txt и откатываются все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, подставляется в команду идентификатор нужного коммита, можно также указать имя файла , но не обязательно:

```
*$ git checkout 78fb164 hello.txt* 
```
или проще: 

```
*$ git checkout 78fb164*
```

Просмотрев данный коммит, поработав с ним, можем вернуться к другому коммиту - совершить перемещение между ними: 

```
git checkout a1e8fb5
```

После этого необходимо вернуться в актуальное состояние. Для этого используем команду ***git checkout*** без дополнительных идентификаторов. 

## 8. Работа с ветками

Для совместной работы над проектом используются ветки. Основная идея работы с функциональными ветками заключается в том, чтобы разработка каждой функции  происходила в отдельной ветке, а не в главной ветке (master). Такое обособление позволяет нескольким разработчикам с легкостью создавать конкретную функцию, не затрагивая основную базу кода. Кроме того, благодаря этому исключены нарушения кода в ветке master, что является важным преимуществом для среды с непрерывной интеграцией.

Для работы с ветками используются следующие команды: 

1. ``` git branch```

Это своего рода “менеджер веток”. Она умеет перечислять Ваши ветки, создавать новые, удалять и переименовывать их.
По умолчанию главной является ветка __master__. Знак ```*``` (Звездочка) указывает в какой ветке Вы работаете в данный момент. 

``` git branch <имя ветки>``` 

Эта команда создает новую ветку с новым именем. 

```git branch -m new-name```

Эта команда переименовывает ветку, на которой Вы находитесь. 

```git branch -m oldname newname``` 

Эта команда переименовывает **произвольную локальную ветку**, т.е. не обязательно ту, на которой Вы находитесь. 

```git branch -d  local_branch_name```

Эта команда удаляет **локальную ветку**. Удалить ветку, в которой Вы находитесь и которую просматриваете в данный момент, нельзя.

2. ```git checkout```

Эта команда используется для переключения между ветками и выгрузки их содержимого в рабочую директорию.

```git checkout branch_name``` 

Эта команда переключает нас с одной ветки на другую. У **текущей** ветки, куда мы переключились появится знак  ```*```  (Звездочка). 

3. ```git log``` 

Эта команда используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

4. ```git stash``` 

Эта команда используется для временного сохранения всех незакоммиченных изменений, для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку. 

5. ```git merge```

Эта команда используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

## 9. Разрешение конфликтов 

**Слияние и конфликты** являются неотъемлемой частью работы с Git.

Обычно **конфликты** возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. **Конфликты** затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

Если при запуске команды ```git merge``` возник __конфликт слияния__, то Ваш терминал или командная строка ответит Вам сообщением:

```CONFLICT (content): Merge conflict in [filename]```

Это сообщение говорит нам, в каком конкретно файле возник __конфликт__.

## 9.1. Поиск конфликта

- Откройте файл, на который указал Git, и прокрутите его, пока не найдете **конфликт**. Ваша _IDE_ может подсказать вам нужное место при помощи ___подсветки___. Редактор **VS Code** подсвечивает текущее изменение и входящее.

__Текущее изменение__ (англ. current change) также иногда называют исходящим. Оно представляет изменения в коде, которые Вы сделали в Вашей локальной ветке.

__Входящее изменение__ (англ. incoming change) представляет изменения в коде, которые вы вытягиваете (pull) из базовой ветки, или изменения, внесенные другими разработчиками.

## 9.2. Решите, какие изменения нужно применить

__Принять оба изменения__ (англ. both changes) позволяет принять изменения, не делая коммит, и локально протестировать программу на работоспособность.

__Сравнить изменения__ (англ. compare changes) позволяет сравнить варианты работы в разных ветках. 

__Удалите__ все длинные последовательности символов ```====``` , ```<<<< или >>>>```

Эти символы используются для того, чтобы помочь Вам определить, где возник конфликт слияния. При принятии выбранных изменений они обычно исчезают, но порой случаются сбои. Проследите за тем, чтобы случайно не включить их в коммит.

Если Вы допустили ошибку или не уверены в том, какие изменения нужно принять, Вы можете остановить процесс слияния, запустив следующую команду:

```git merge --abort```

### 9.3. Коммит изменений 

Если Вы уверены, что конфликт разрешен, сделайте коммит изменений

После принятия нужных изменений Вы можете сделать коммит. 


Для этого нужно Вам проделать следующие шаги:

- Сохраните файлы, в которые были внесены изменения
- Запустите ```git status``` и проверьте, что изменения коснулись правильных файлов
- Добавьте выбранные файлы в стейджинг: ```git add [имя файла]```
- Сделайте коммит изменений: ```git commit -m «[ваше сообщение коммита]»```
- Запустите ```git push```

## 10. Работа со списком игнорируемых файлов 

Для того, что создать ___неотслеживаемый (игнорируемый)___ файл или список файлов, необходимо в папке, где Вы работате, создать файл с названием ```.gitignore``` и добавить в него файлы, которые необходимо игнорировать. 

Такие файлы подсвечиваются серым цветом. 

## 11. Работа с удаленными репозиториями

Для совместной работы, обновления проектов и размещения собственных проектов используется крупнейшее хранилище Git-репозиториев GitHub. При помощи сервиса GitHub осуществляется работа с удаленными репозиториями. 

1. Для старта работы с **GitHub** необходимо создать ***аккаунт*** на **https://github.com**, пройдя стандартную процедуру регистрации. 

2. Для создания своего удаленного репозитория на **GitHub** нужно войти в систему, затем в навигационной панели сверху рядом с Вашим именем выбрать: 

 ```"​+​"``` и ```"​New repository​"``` 

или на главной странице ___зеленая кнопка___ ```"​+ New repository​"``` 

и далее заполнить поля:

- *Repository name*​ - имя репозитория
- *Description​* - описание репозитория (опционально)
- выбрать каким будет репозиторий **"​Public​"** (публичный) или **"Private"** (частный) 
- добавить файл ___README___ при необходимости
- добавить файлы для игнортрования в ```.gitignore``` (предлагаются шаблоны)
- выбрать лицензию (предлагаются шаблоны)

Нажимаем кнопку ```"​Create repository​"```. ***Репозиторий создан!*** 

Теперь он доступен по адресу: https://github.com/SafiiaM/Test-Geekbrains

Репозиторий, находящийся на **GitHub**, мы будем называть ​главным​.

3. При передаче данных с **локального** на **удаленный** репозиторий, необходимо будет ___"подружить"___ эти репозитории. **GitHub** при создании репозитория подскажет как єто сделать. 

4. ```Fork``` - ***создание копии удаленного репозитория***

***Fork*** - это вcего навсего копия ___удаленного___ репозитория. Это тоже самое, что ***branch*** в **Git**. Только на **GitHub** такой ***branch*** называется ___fork___.
Само слово fork в переводе означает *ответвление*. 
С помощью него создается точная копия оригинального репозитория, только на сервисе **GitHub**. В копии репозитория можно вносить свои собственные изменения, редактировать файлы или удалять директории.

Для того, чтобы воспользоваться ```fork``` на **GitHub** через поиск интересующий нас репозиторий в открытом доступе, заходим в этот репозиторий и там выполняем команду ```Fork``` в верхнем правом углу. 

Как только все изменения будут внесены, то можно поделиться ими - отправить авторам оригинального репозитория запрос на слияние Вашего измененного репозитория с их оригинальным репозиторием. Такой запрос называется ```pull request```

5. ```Pull request```

После создания запроса на слияние при помощи кнопки ***"Create Pull request"*** получит уведомление о предложенных изменениях со ссылкой на страницу с информацией о запросе. 

6. *Основные команды при работе с удаленными репозиториями*: 

- ```git clone <ссылка на удаленный репозиторий в GitHub>```

Эта команда создает **локальную** копию главного репозитория на Вашем компьютере. 
Напрмер: 

         git clone https://github.com/SafiiaM/Test-Geekbrains 
 ​
- ```cd <имя файла>``` 

Эта команда (***change directory***) переходит в каталог репозитория к определенному файлу 

- ```git fetch```

Эта команда связывается с **удалённым** репозиторием и забирает из него все изменения, которых у Вас пока нет и сохраняет их локально

- ```git pull``` 

Эта команда работает как комбинация команд ```git fetch``` и ```git merge```, т.е. **Git** вначале забирает изменения из указанного **удалённого** репозитория, а затем пытается слить их с текущей веткой.

- ```git push```

Эта клманда используется для установления связи с **удалённым** репозиторием, вычисления локальных изменений, отсутствующих в нём, и, собственно, их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию. 

Эта команда немного похожа на ```git fetch```, с той лишь разницей, что при помощи ***fetch*** мы ___импортируем коммиты в локальную ветку___, а, применив ***push***, мы ___экспортируем их из локальной в удаленную___. 

> Подытожив сказанное, можно назвать ```git push``` - командой выгрузки, а ```git pull``` и ```git fetch``` - командами загрузки или скачивания. 

- ```git remote```

Эта команда служит для управления списком **удалённых** репозиториев. Она позволяет сохранять длинные *URL* репозиториев в виде понятных коротких строк, например ___"origin"___, так что Вам не придётся забивать голову _"всякой ерундой"_ и набирать _""её""_ каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и ```git remote``` поможет добавлять, изменять и удалять их.

## 12. Заключение  

> Теперь Вы умеете выполнять ___все базовые локальные операции с Git___: 
>> создавать или клонировать репозиторий, 

>> вносить изменения, 

>>индексировать и фиксировать эти изменения, 
>> а также просматривать историю всех изменений в репозитории.

>> работать с ветками 

>> разроешать конфликты 
>> работать с игнорируемыми файлами
>> работать с удаленными репозиториями

## 13. P.S. 

Если Вы не до конца настроили систему для работы, в начале своего пути - не беда. **Git** всегда подскажет разработчику, если тот запутался, например:
1.	Команда ```git --help``` - выводит общую документацию по **Git**
2.	Команда ```git log --help``` - предоставит нам документацию по какой-то определенной команде (в данном случае это - _log_)
3.	Если Вы вдруг сделали опечатку - система подскажет Вам нужную команду
4.	После выполнения любой команды - отчитается о том, что Вы *"натворили"*
5.	Также **Git** прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше
Тут стоит отметить, что подсказывать система будет на ***английском***, но не волнуйтесь, со временем Вы изучите несложный алгоритм ее работы и будете разговаривать с ней на одном языке.




![Привет git better!](git.jpg)
